11


#include <iostream>
#instdlib>
#include <cstring>
#include <string>
#include <unistd <unistd.h>
#include <sys/sockenclude <netinet/in.h>
#include <arpa/inet.h>
#include <dirent.<dirent.h>
#include <pthread.h>de <sys/time.h>
#include <fcntl.h>
#include <sys/stat.h>  // Fh>  // For mkdir
#include <errn // For errno
#include <vector> // Added for scan_seeds_for_fil_for_file
#include <iomanip> //or setprecision
#include <fstream> // For file logging
#includ
#include <sstream> // For strin operations

// Port configuration - easily changeable
const 
const int PORTS[] = {8080, 808 8083, 8084};
const int MAX_PORTS = 5;
const int MAX_FILES = 1ILES = 100;
const int MAX_FILENTH = 256;

// Download configuration
const int CHUNK_DELAY_MIDELAY_MICROSECONDS = 5000; // 10y between chunks

//global variables
typedef struct {
    in
    int port;
    int folder_ char folder_path[256];
    int socket_FileHandle; //for serverr server side, file handling
  _bound;
    pthread_t thread_id;
    int thread_index;
} port
} port_thread_data_t;

typedt {
    char filename[MAX_FILENAME_LENGTH];
    int source_porurce_port;
}file_info_t;

por_data_t port_threads[MAX_PORTS];
int bound_port_count = 0;
fil 0;
file_info_t unique_files[MA;  // Use the structure instead of char array
int unique_file_ce_file_count = 0;
int my_bound_1; 

pthread_mutex_t file_list_mutex = PTHREAD_MUTEX_INITIALIZNITIALIZER;

// Logging systemfstream client_log_file;
std::ofstream server_log_file;
pthrea
pthread_mutex_t client_log_mutREAD_MUTEX_INITIALIZER;
pthread_mutex_t server_log_mutex = PTHRx = PTHREAD_MUTEX_INITIALIZER;
ing client_log_filename;
std::string server_log_filename;
boole;
bool client_logging_active =
bool server_logging_active = false;

// Download thread data ad data structure
typedef struc char filename[MAX_FILENAME_LENGTH];
    std::vector<int>* avait>* available_seeds;
    pthreaad_id;
    bool is_active;
    long long total_size;
    long    long long downloaded_bytes; total_chunks;
    int completed_chunks;
} download_thread_datread_data_t;

// Global downlod management
download_thread_data_t active_download;
pthread_mthread_mutex_t download_thread_mTHREAD_MUTEX_INITIALIZER;

// Function prototypes
void init_cd init_client_logging();
void ier_logging();
void log_client(const std::string& message);
voie);
void log_server(const std::message);
void close_client_logging();
void close_server_loggier_logging();
std::string get_t();
std::string format_file_size(long long bytes);
void* downld* download_thread_worker(void* oid scan_seeds_for_file(const char* filename, std::vector<int>& r<int>& available_seeds);
void _file_round_robin(const char* filename, const std::vector<int>& r<int>& available_seeds);
void gress_bar(long long current, long long total, int bar_width = 50dth = 50);
long long get_file_s_seed(int port, const char* filename);
bool check_file_already_already_exists(const char* fileng long expected_size, char* existing_path, size_t path_size);
ize);

void setup_socket_addr(ockaddr_in* addr, int port) {
    memset(addr, 0, sizeof(*addr)f(*addr));
    addr->sin_familyET;
    addr->sin_addr.s_addr = INADDR_ANY;
    addr->sin_portsin_port = htons(port);
}

//function to create directories recursively
int create_directoryirectory(const char* path) {
  emp[1024];
    char* pos = NULL;
    
    // Safe string copying copy with bounds checking
 trlen(path) >= sizeof(temp)) {
        return -1; // Path too lth too long
    }
    
    stmp, path, sizeof(temp) - 1);
    temp[sizeof(temp) - 1] = '\0'; = '\0'; // Ensure null terminat 
    auto len = strlen(temp);
    
    // Remove trailing sliling slash if present
    if (&& temp[len - 1] == '/') {
        temp[len - 1] = '\0';
     ;
        len--;
    }
    
reate directories recursively
    for (pos = temp + 1; *pos; po*pos; pos++) {
        if (*pos {
            *pos = '\0';
            if (mkdir(temp, 0755) , 0755) != 0 && errno != EEXIST)            return -1;
            }
            *pos = '/';
= '/';
        }
    }
    
reate the final directory
    if (mkdir(temp, 0755) != 0 && err0 && errno != EEXIST) {
       -1;
    }
    
    return 0;
}

// Logging system implemenimplementation
std::string get_p() {
    time_t now = time(0);
    struct tm* timeinfo = locao = localtime(&now);
    char b];
    strftime(buffer, sizeof(buffer), "%Y%m%d_%H%M%S", timein, timeinfo);
    return std::stfer);
}

std::string format_file_size(long long bytes) {
   ) {
    const char* units[] = {", "MB", "GB", "TB"};
    int unit_index = 0;
    double size le size = bytes;
    
    whil>= 1024.0 && unit_index < 4) {
        size /= 1024.0;
       
        unit_index++;
    }
  char buffer[32];
    if (unit_index == 0) {
        snprintf(nprintf(buffer, sizeof(buffer), , (long long)size, units[unit_index]);
    } else {
        sn      snprintf(buffer, sizeof(bu%.1f%s", size, units[unit_index]);
    }
    
    return std:urn std::string(buffer);
}

v_client_logging() {
    if (client_logging_active) return; // Arn; // Already initialized
    d::string timestamp = get_timestamp();
    client_log_filename ilename = "download_file_" + getmp() + "_port" + std::to_string(my_bound_port) + ".log";
    

    
    pthread_mutex_lock(&og_mutex);
    client_log_file.open(client_log_filename, std::i, std::ios::out | std::ios::app)
    if (client_log_file.is_open()) {
        client_logging_acgging_active = true;
        
time_t now = time(0);
        struct tm* timeinfo = localtime(&altime(&now);
        char timer[80];
        strftime(timestamp_str, sizeof(timestamp_str), "_str), "%Y-%m-%d %H:%M:%S", time        
        client_log_file << "[" << timestamp_str << "] r << "] === DOWNLOAD SESSION STA" << std::endl;
        client_log_file << "[" << timestamp_strtamp_str << "] Client bound to p< my_bound_port << std::endl;
        client_log_file.flush();lush();
        
    }
    pttex_unlock(&client_log_mutex);
}

void init_server_logging() gging() {
    if (server_loggin) return; // Already initialized
    
    std::string timestamtimestamp = get_timestamp();
  _log_filename = "seedapp_port" + std::to_string(my_bound_port) +_port) + "_log_" + timestamp + "    
    pthread_mutex_lock(&server_log_mutex);
    server_logrver_log_file.open(server_log_fistd::ios::out | std::ios::app);
    
    if (server_log_file.ig_file.is_open()) {
        sering_active = true;
        
        time_t now = time(0);
   0);
        struct tm* timeinfotime(&now);
        char timestamp_str[80];
        strftime(trftime(timestamp_str, sizeof(timtr), "%Y-%m-%d %H:%M:%S", timeinfo);
        
        server_lserver_log_file << "[" << timest<< "] === SEED SERVER LOG STARTED ===" << std::endl;
        se      server_log_file << "[" << p_str << "] Server listening on port: " << my_bound_port << std: << std::endl;
        server_lflush();
        
    }
    pthread_mutex_unlock(&server_log_ver_log_mutex);
}

void log_cnst std::string& message) {
    if (!client_logging_active) {
ive) {
        init_client_logg    }
    
    pthread_mutex_lock(&client_log_mutex);
    if 
    if (client_log_file.is_open       time_t now = time(0);
        struct tm* timeinfo = locao = localtime(&now);
        chtamp[80];
        strftime(timestamp, sizeof(timestamp), "%Y-%m, "%Y-%m-%d %H:%M:%S", timeinfo)   
        client_log_file << "[" << timestamp << "] " << mess << message << std::endl;
     t_log_file.flush();
    }
    pthread_mutex_unlock(&client_logient_log_mutex);
}

void log_onst std::string& message) {
    if (!server_logging_active) {tive) {
        init_server_log
    }
    
    pthread_mutex_lock(&server_log_mutex);
    if
    if (server_log_file.is_ope        time_t now = time(0);
        struct tm* timeinfo = locfo = localtime(&now);
        cstamp[80];
        strftime(timestamp, sizeof(timestamp), "%Y-%), "%Y-%m-%d %H:%M:%S", timeinfo    
        server_log_file << "[" << timestamp << "] " << mes" << message << std::endl;
    er_log_file.flush();
    }
    pthread_mutex_unlock(&server_loerver_log_mutex);
}

void clot_logging() {
    pthread_mutex_lock(&client_log_mutex);
    i;
    if (client_log_file.is_opclient_logging_active) {
        time_t now = time(0);
       
        struct tm* timeinfo = l(&now);
        char timestamp[80];
        strftime(timestampimestamp, sizeof(timestamp), "%YH:%M:%S", timeinfo);
        
        client_log_file << "[" <<< "[" << timestamp << "] === DOESSION ENDED ===" << std::endl;
        client_log_file.close().close();
        client_loggin = false;
    }
    pthread_mutex_unlock(&client_log_mutex);
utex);
}

void close_server_l {
    pthread_mutex_lock(&server_log_mutex);
    if (server_lserver_log_file.is_open() && sering_active) {
        time_t now = time(0);
        struct tm*ruct tm* timeinfo = localtime(&n      char timestamp[80];
        strftime(timestamp, sizeof(tiizeof(timestamp), "%Y-%m-%d %H:%imeinfo);
        
        server_log_file << "[" << timestampimestamp << "] === SEED SERVER L ===" << std::endl;
        server_log_file.close();
        s       server_logging_active = f       std::cout << "Server logging ended: " << server_log_filenog_filename << std::endl;
    }hread_mutex_unlock(&server_log_mutex);
}

// Download thread  thread worker function
void* dthread_worker(void* arg) {
    download_thread_data_t* downloaddownload_data = (download_thread)arg;
    
    log_client("Background download thread started started for file: " + std::strinad_data->filename));
    
    // Perform the actual download
wnload
    download_file_round_wnload_data->filename, *(download_data->available_seeds));
    );
    
    // Clean up
    putex_lock(&download_thread_mutex);
    delete download_data->avdata->available_seeds;
    downa->is_active = false;
    pthread_mutex_unlock(&download_threadd_thread_mutex);
    
    log_Background download thread completed for file: " + std::string(dstring(download_data->filename))
    return NULL;
}

// //Checks if a port is available by atle by attempting a temporary bint is_port_available(int port) {
//     int sock = socket(AF_INEt(AF_INET, SOCK_STREAM, 0);
// sock < 0) {
//         return 0;
//     }

//     struct socruct sockaddr_in addr;
//     sket_addr(&addr, port);

//     int result = bind(sock, (struct (struct sockaddr*)&addr, sizeof 
//     close(sock);

//     return result == 0;
// }

// }

//This will permanently bie port and starts listening
int bind_and_listen(int port) {
  t) {
    int sock = socket(AF_IK_STREAM, 0);
    if (sock < 0) {
        return -1;
    }
    }

    int opt = 1;
    st(sock, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    str
    struct sockaddr_in addr;
 _socket_addr(&addr, port);

    if (bind(sock, (struct sockadd sockaddr*)&addr, sizeof(addr))         close(sock);
        return -1;
    }

    if (listef (listen(sock, 5) < 0) {
     (sock);
        return -1;
    }

    return sock;
}

//t}

//this will help prevent du
void add_unique_file(const char* filename, int source_port) {port) {
    pthread_mutex_lock(st_mutex);
    
    for (auto i = 0; i < unique_file_count; i+ount; i++) {
        if (strcmpfiles[i].filename, filename) == 0) {
            pthread_mutex_d_mutex_unlock(&file_list_mutex)       return;
        }
    }
    
    if (unique_file_counile_count < MAX_FILES) {
      e string copy with bounds checking
        if (strlen(filename)ilename) < MAX_FILENAME_LENGTH)        strncpy(unique_files[unique_file_count].filename, filenam filename, MAX_FILENAME_LENGTH -          unique_files[unique_file_count].filename[MAX_FILENAME_ILENAME_LENGTH - 1] = '\0'; // Ell termination
            unique_files[unique_file_count].sournt].source_port = source_port;
    unique_file_count++;
        }
    }
    pthread_mutex_unmutex_unlock(&file_list_mutex); Get files from our own folder (for serving to other ports)
voits)
void get_own_files(char* reint max_size) {
    auto my_folder_id = -1;

    for (auto i (auto i = 0; i < MAX_PORTS; i++)    if (PORTS[i] == my_bound_port) {
            my_folder_id =der_id = i + 1;
            bre     }
    }
    
    if (my_folder_id == -1) {
        resp    response[0] = '\0';  // Safeclear string
        return;
    }
    
    char folder_pathder_path[256];
    snprintf(fol, sizeof(folder_path), "files/seed%d/%d", my_folder_id, my_foldemy_folder_id);
    
    respon'\0';
    DIR *dr = opendir(folder_path);
    if (dr != NULL) = NULL) {
        struct dirent       auto file_count = 0;
        
        while ((de = reade = readdir(dr)) != NULL) {
    if (strcmp(de->d_name, ".") != 0 && strcmp(de->d_name, "..") !="..") != 0) {
                c_entry[512];
                snprintf(file_entry, sizeof(file_ef(file_entry), "[%d] %s\n", ++fi, de->d_name);
                
                // Safe stringe string concatenation with bouning
                size_t current_len = strlen(response);
   e);
                size_t entrstrlen(file_entry);
                if (current_len + entry_lenntry_len < (size_t)max_size - 1)                strncat(response, file_entry, max_size - current current_len - 1);
            se {
                    break; // Buffer full, stop adding filding files
                }
    }
        }
        closedir(dr);
    }
}

// Handle poandle port requests (server side port_request(void* arg) {
    auto client_filehandle = *(int*) *(int*)arg; // extract the valuree(arg);  //free the memory
    
    char buffer[1024]; //buf]; //buffer to hold the data froient
    auto bytes = recv(client_filehandle, buffer, sizeof(buizeof(buffer) - 1, 0); //waits c send something
    if (bytes <= 0) {
        close(client_filient_filehandle);
        retur
    }
    buffer[bytes] = '\0';
    


    if (strcmp(buffcmp(buffer, "LIST") == 0) {
   r response[2048];
        get_own_files(response, sizeof(responf(response));
        send(clieandle, response, strlen(response), 0); //sending back to client client
    }
    else if (strfer, "FILESIZE ", 9) == 0) {
        // Handle FILESIZE command command
        char filename[NAME_LENGTH];
        size_t filename_len = strlen(buffer + 9);er + 9);
        if (filename_l_FILENAME_LENGTH) {
            strncpy(filename, buffer + 9, Mr + 9, MAX_FILENAME_LENGTH - 1);      filename[MAX_FILENAME_LENGTH - 1] = '\0';
        } else  } else {
            char erro= "ERROR: Filename too long";
            send(client_filehandlilehandle, error_msg, strlen(err 0);
            close(client_filehandle);
            return  return NULL;
        }
          // Remove trailing whitespace/newlines
        auto newline newline = strchr(filename, '\n'    if (newline) *newline = '\0';
        
        // Find theFind the file and get its size
auto my_folder_id = -1;
        for (auto i = 0; i < MAX_PORTS;X_PORTS; i++) {
            if ] == my_bound_port) {
                my_folder_id = i + 1;
  + 1;
                break;
    }
        }
        
        if (my_folder_id != -1) {
   ) {
            char file_path[            snprintf(file_path, sizeof(file_path), "files/seed%ds/seed%d/%d/%s", my_folder_id, m_id, filename);
            
            FILE *file = fopen(fifopen(file_path, "rb");
       (file) {
                // Get exact file size
                        fseek(file, 0, SEEK_EN             long file_size = ftell(file);
                fclo    fclose(file);
                          // Send size response
                char size_re size_response[64];
           rintf(size_response, sizeof(size_response), "SIZE:%ld", file_sizfile_size);
                sen_filehandle, size_response, strlen(size_response), 0);
                        
              tringstream ss;
                ss << "SEED PORT " << my_bound_y_bound_port << ": Client reques size for '" << filename << "' → Responding with " << file_sizfile_size << " bytes";
        log_server(ss.str());
            } else {
                cha     char error_msg[] = "ERROR:  found";
                send(client_filehandle, error_msg, strmsg, strlen(error_msg), 0);
    }
        }
    }
    else if (strncmp(buffer, "DOWNLOAD ", LOAD ", 9) == 0) {
        // PNLOAD command - format: "DOWNLOAD filename offset"
        char    char filename[MAX_FILENAME_L
        long long offset = 0;
        
        // Parse filense filename and offset using | d
        char* delimiter_pos = strchr(buffer + 9, '|');
      
        if (delimiter_pos) {
    // Has offset parameter
            size_t filename_len = d_len = delimiter_pos - (buffer +          if (filename_len < MAX_FILENAME_LENGTH) {
                        strncpy(filename, b9, filename_len);
                filename[filename_len] = '\0'] = '\0';
                offsel(delimiter_pos + 1);
            } else {
                cha     char error_msg[] = "ERROR:  too long";
                send(client_filehandle, error_msg, or_msg, strlen(error_msg), 0);
        close(client_filehandle);
                return NULL;n NULL;
            }
        
            // No offset, use original parsing
            si      size_t filename_len = strlr + 9);
            if (filename_len < MAX_FILENAME_LENGTH) {
GTH) {
                strncpy(, buffer + 9, MAX_FILENAME_LENGTH - 1);
                filenam filename[MAX_FILENAME_LENGTH - ';
            } else {
                char error_msg[] = "ER[] = "ERROR: Filename too long";          send(client_filehandle, error_msg, strlen(error_msg), r_msg), 0);
                clot_filehandle);
                return NULL;
            }
     }
        }
        
      ove trailing whitespace/newlines
        auto newline = strchr( strchr(filename, '\n');
      wline) *newline = '\0';
        
        std::stringstream ss;ream ss;
        ss << "SEED POmy_bound_port << ": Download request for '" << filename << "' st<< "' starting at byte " << offs     log_server(ss.str());
        
        // Find the file ie file in our folder
        aulder_id = -1;
        for (auto i = 0; i < MAX_PORTS; i++) {
 ++) {
            if (PORTS[i] und_port) {
                my_folder_id = i + 1;
                        break;
               }
        
        if (my_folder_id != -1) {
            c       char file_path[1024];
    snprintf(file_path, sizeof(file_path), "files/seed%d/%d/%s", md/%s", my_folder_id, my_folder_iame);
            
            FILE *file = fopen(file_path, "_path, "rb");
            if (f                // Get file size
                fseek(file, 0,file, 0, SEEK_END);
           g file_size = ftell(file);
                fseek(file, 0, SEEK_0, SEEK_SET);
                         std::stringstream ss2;
                ss2 << "SEED PO"SEED PORT " << my_bound_port << found (" << file_size << " bytes total)";
                log_    log_server(ss2.str());
        
                // Check if offset is valid
                        if (offset >= file_si                   log_server("SEED: Offset beyond file size, nosize, no more data to send");
            fclose(file);
                    close(client_filehnt_filehandle);
               urn NULL;
                }
                
                        // Seek to the requested
                fseek(file, offset, SEEK_SET);
                        
                // Se2-byte chunk from the offset
                char file_buffer[3buffer[32];
                sizs_read = fread(file_buffer, 1, sizeof(file_buffer), file);
    );
                auto total_s
                
                if (bytes_read > 0) {
     {
                    if (send(ilehandle, file_buffer, bytes_read, 0) <= 0) {
                                log_server("SEEDailed!");
                    } else {
                                total_sent += bytes_rea                    std::stringstream ss3;
                                if (bytes_read == 32                         ss3 << "SEED PORT " << my_bound_port <<_port << ": Sent full chunk (32 rom position " << offset << " to " << (offset + bytes_read - 1);ad - 1);
                       {
                            ss3 << "SEED PORT " << my_bound_y_bound_port << ": Sent final ch< bytes_read << " bytes) from position " << offset << " to " << to " << (offset + bytes_read - 1 FILE COMPLETE!";
                        }
                                log_server(ss3.str                  }
                } else {
                            std::stringstream ss4               ss4 << "SEED PORT " << my_bound_port << ": No dat: No data available at offset " t << " (file may be complete)";
                    log_server(_server(ss4.str());
                           
                fclose(file);
                        std::stringstream ss5;         ss5 << "SEED: Sent " << total_sent << " bytes of file 'f file '" << filename << "'.";
        log_server(ss5.str());
            } else {
                        std::stringstream               ss6 << "SEED PORT " << my_bound_port << ": File '" File '" << filename << "' not flocal storage";
                log_server(ss6.str());
       
                
             nd error message
                char error_msg[] = "ERROR: FilROR: File not found";
         end(client_filehandle, error_msg, strlen(error_msg), 0);
      
            }
        }
    
    close(client_filehandle);
    return NULL;
}

// Server/ Server thread to accept port cns
void* server_thread(void* arg) {
    //int server_filehandlilehandle = port_threads[0].sockandle; //setting a socket file handle for the server

    auto    auto server_filehandle = *(i //this will get the client file handle from the argument
    ft
    free(arg); //this will reap memory in the malloc

    struct sockaddr_in client_addr;
_addr;
    socklen_t client_lenf(client_addr);
    
    while (1) { //loop infinitely
      
        auto client_filehandlet(server_filehandle, (struct sockaddr*)&client_addr, &client_lenient_len); // this will wait fororts
        if (client_filehandle >= 0) {
            auto cl auto client_filehandle_ptr = (ioc(sizeof(int));  // ths will allocate separate
            //      // memory for the clients fle so each threads has its own copy
            if (client_fileent_filehandle_ptr == NULL) {
        log_server("Error: Memory allocation failed");
                        close(client_file
                continue;
            }
          
                    *client_filehandle_pent_filehandle;
            
            //this will create a reate a new thread for each clie        pthread_t handler_thread;
            pthread_create(&hreate(&handler_thread, NULL, port, client_filehandle_ptr); //If new port is bounded, it will crewill create a new thread
      hread_detach(handler_thread);
        }
    }
    return NULLurn NULL;
}

void port_server  std::cout << "Finding available ports...";
    
    for (autfor (auto i = 0; i < MAX_PORTS;         auto port = PORTS[i];
        
        //if (is_port_as_port_available(port)) {
     uto sock = bind_and_listen(port);
            if (sock >= 0) {>= 0) {
                my_boun port;
                
                // Set up port thread  thread data
                pods[0].port = port;
                port_threads[0].folder_id = er_id = i + 1;
                eads[0].thread_index = 0;
                port_threads[0].socke0].socket_FileHandle = sock;
        port_threads[0].is_bound = 1;
                snprintf(porintf(port_threads[0].folder_patf(port_threads[0].folder_path), 
                         "file   "files/seed%d/%d", port_threalder_id, port_threads[0].folder_id);
                
                        bound_port_count               
                std::cout << " Found port " << rt " << port << "." << std::endl           std::cout << "Listening at port " << port << "." << s"." << std::endl;
                          // Start server thread to handle port requests

 sts

                auto servandle_ptr = (int*)malloc(sizeof(int));  
                if (se  if (server_filehandle_ptr == N                    log_server("Error: Memory allocation failed" failed");
                    ck);
                    return;
                }
                        *server_filehandleock;
                pthread_t server_tid;
                pth     pthread_create(&server_tid,erver_thread, server_filehandle_ptr);
                pthread_dthread_detach(server_tid);
        
                return;
            }
        //}
    }}
    }
    
    std::cout <<ailable ports found." << std::endl;
}

void download_file(){file(){
    
     // Check if any files to download
     pthread_mutex_lock(&file_list_mutex)t_mutex);
     if (unique_file_ 0) {
         log_client("No files available to download. Pleaad. Please list files first (opt);
         std::cout << "No files available to download. Pleasd. Please list files first (opti<< std::endl;
         pthread_mutex_unlock(&file_list_mutex);mutex);
         return;
     
     // Show available files
     std::cout << "Available filable files for download:" << std
     for (auto i = 0; i < unique_file_count; i++) {
         s       std::cout << "[" << i + 1 << 
                unique_files[i].filename << " (from seed am seed at port " << unique_filesce_port << ")" << std::endl;
     }
     
     // Get user's  user's choice
     std::cout <er file ID: ";
     auto file_choice = 0;
     std::cin >> filn >> file_choice;
     
     /te choice
     if (file_choice < 1 || file_choice > unique_fileque_file_count) {
         log_Locating seeders... Failed - No seeders for file ID " + std::to_std::to_string(file_choice));
 std::cout << "Locating seeders... Failed" << std::endl;
       
         std::cout << "No seedeile ID " << file_choice << "." <<std::endl;
         pthread_muhread_mutex_unlock(&file_list_mu        return;
     }
     
     // Get file info before relfore releasing the mutex
     cname[MAX_FILENAME_LENGTH];
     // Safe string copy with boundsh bounds checking
     size_t flen = strlen(unique_files[file_choice - 1].filename);
     if (    if (filename_len < MAX_FILENTH) {
         strncpy(filename, unique_files[file_choice - 1].ce - 1].filename, MAX_FILENAME_L1);
         filename[MAX_FILENAME_LENGTH - 1] = '\0'; // Ensur// Ensure null termination
    {
         log_client("Error: Filename too long.");
         s       std::cout << "Error: File long." << std::endl;
         pthread_mutex_unlock(&file_list_le_list_mutex);
         return}
     pthread_mutex_unlock(&file_list_mutex);
     
     log     log_client("Scanning all sefile '" + std::string(filename) + "'...");
     std::cout << "Sut << "Scanning all seeds for fi filename << "'..." << std::endl;
     
     // Scan all seedsll seeds for this file
     std<int> available_seeds;
     scan_seeds_for_file(filename, availe, available_seeds);
     
   ailable_seeds.empty()) {
         log_client("No seeds found wifound with file '" + std::stringe) + "'. Cannot download.");
         std::cout << "No seeds foseeds found with file '" << file"'. Cannot download." << std::endl;
         return;
     }
     }
     
     // Get expectsize from one of the seeds
     auto expected_size = get_file_st_file_size_from_seed(available_, filename);
     if (expected_size <= 0) {
         log_clienog_client("Could not determine f. Download may fail.");
         std::cout << "Could not determt determine file size. Download ." << std::endl;
     } else {
         log_client("Expected fpected file size: " + std::to_stected_size) + " bytes");
         std::cout << "Expected file sd file size: " << expected_size es" << std::endl;
         
         // Check if file already already exists locally with corr
         char existing_path[1024];
         if (check_file_al_file_already_exists(filename, esize, existing_path, sizeof(existing_path))) {
             log     log_client("File [" + std::g(file_choice) + "] " + std::string(filename) + " already existsy exists");
             std::c File [" << file_choice << "] " << filename << " already exists" exists" << std::endl;
        urn;
         } else {
             log_client("File not foundot found locally or size mismatcing download...");
             std::cout << "File not found lofound locally or size mismatch.  download..." << std::endl;
         }
     }
     
     //      // Check if there's alreadyve download
     pthread_mutex_lock(&download_thread_mutex);
 tex);
     if (active_download.e) {
         std::cout << "A download is already in progress. ogress. Please wait for it to co << std::endl;
         log_client("Download request rejected -jected - another download alreadgress");
         pthread_mutex_unlock(&download_thread_mutex);_mutex);
         return;
     
     // Set up download thread data
     strncpy(active_downive_download.filename, filename,ENAME_LENGTH - 1);
     active_download.filename[MAX_FILENAME_LLENAME_LENGTH - 1] = '\0';
    download.available_seeds = new std::vector<int>(available_seeds)e_seeds);
     active_download.e = true;
     
     // Initialize progress tracking
     act     active_download.total_size    active_download.downloaded_bytes = 0;
     active_download.twnload.total_chunks = 0;
     awnload.completed_chunks = 0;
     
     // Create background dground download thread
     if _create(&active_download.thread_id, NULL, download_thread_workerd_worker, &active_download) != 0      std::cout << "Error: Failed to create download thread" << ead" << std::endl;
         log"Error: Failed to create download thread");
         delete actlete active_download.available_s        active_download.is_active = false;
         pthread_mutread_mutex_unlock(&download_thre);
         return;
     }
     
     // Detach thread so itad so it runs independently
   d_detach(active_download.thread_id);
     pthread_mutex_unlock(_unlock(&download_thread_mutex);
     std::cout << "Download started in background for file: " <ile: " << filename << std::endl;td::cout << "You can continue using the menu while the download ownload progresses." << std::end log_client("Background download initiated for file: " + std::st std::string(filename));
}

/nction to scan multiple seeds for the same file
void scan_seedsan_seeds_for_file(const char* fistd::vector<int>& available_seeds) {
    available_seeds.clear(s.clear();
    
    // Try to to all other ports (excluding current bound port)
    for (autoor (auto i = 0; i < MAX_PORTS; i       auto port = PORTS[i];
        if (port != my_bound_port)nd_port) {  // Skip current boun            log_client("Scanning seed at port " + std::to_stringo_string(port) + " for file '" +ring(filename) + "'...");
            std::cout << "Scanning senning seed at port " << port << 
            
            auto sock = socket(AF_INET, SOCK_STREOCK_STREAM, 0);
            if 0) {
                log_client("socket failed for port " + std " + std::to_string(port));
        std::cout << "failed" << std::endl;
                contin  continue;
            }
    
            struct sockaddr_in addr;
            addr.sin_fam.sin_family = AF_INET;
        .sin_port = htons(port);
            inet_pton(AF_INET, "127.0. "127.0.0.1", &addr.sin_addr);
    
            if (connect(sock, (struct sockaddr*)&addr, sizddr, sizeof(addr)) == 0) {
        // Send LIST command to check if file exists
                        send(sock, "LIST", strT"), 0);
                
                char buffer[1024];
1024];
                auto n =ck, buffer, sizeof(buffer) - 1, 0);
                if (n > 0) (n > 0) {
                    b = '\0';
                    
                    // Check if heck if filename exists in this ile list
                    char* line = strtok(buffer, "\n");, "\n");
                    bofound = false;
                    log_client("Checking files o files on seed " + std::to_strin+ ":");
                    while (line != NULL) {
                                auto brackestrchr(line, ']');
                        if (bracket_end && bend && bracket_end[1] == ' ') {                     auto seed_filename = bracket_end + 2;
    2;
                            nt("  Found: '" + std::string(seed_filename) + "' (length: " + sh: " + std::to_string(strlen(seeme)) + ")");
                            if (strcmp(seed_filenad_filename, filename) == 0) {
                        file_found = true;
                                        log_client(" );
                                break;
                                    }
                }
                        line = strtok(NULL, "\n");
      
                    }
            
                    if (file_found) {
                                log_client("FOUND!                     std::cout << "found" << std::endl;
       
                        availab.push_back(port);
                    } else {
                                log_client("not;
                        std::cout << "not found" << std::endltd::endl;
                    }          } else {
                    log_client("no response esponse from port " + std::to_stt));
                    std::cout << "no response" << std::endstd::endl;
                }
    } else {
                log_client("port " + std::to_stringo_string(port) + " not running")           std::cout << "not running" << std::endl;
                    }
            
      ose(sock);
        }
    }
    
    log_client("Found " + std " + std::to_string(available_se()) + " seed(s) with file '" + std::string(filename) + "'");
 "'");
    std::cout << "Found "lable_seeds.size() << " seed(s) with file '" << filename << "'"  << "'" << std::endl;
    
   to get file size from first available seed for progress trackingtracking
    if (!available_see()) {
        auto file_size = get_file_size_from_seed(availablavailable_seeds[0], filename);
if (file_size > 0) {
            log_client("Estimated file sizfile size: " + std::to_string(fi + " bytes");
        }
    }
}

// New function to downloa download file using round-robinistribution
void download_file_round_robin(const char* filenamefilename, const std::vector<int>ble_seeds) {
    if (available_seeds.empty()) {
        log_cl  log_client("No seeds availables file.");
        std::cout << "No seeds available for this fi this file." << std::endl;
    rn;
    }
    
    const int CHUNK_SIZE = 32;  // Fixed 32-byed 32-byte chunks
    auto tota= available_seeds.size();
    auto current_seed_index = 0;
    0;
    
    // Determine loca structure
    auto my_folder_id = -1;
    for (auto i = 0; i  = 0; i < MAX_PORTS; i++) {
   (PORTS[i] == my_bound_port) {
            my_folder_id = i + 1;= i + 1;
            break;
  
    }
    
    if (my_folder_id == -1) {
        log_client(_client("Error: Could not determl folder.");
        std::cout << "Error: Could not determine lermine local folder." << std::en     return;
    }
    
    // We'll determine the download dwnload directory after getting t chunk
    char download_dir[1024];
    char download_path[102path[1024];
    FILE *output_filptr;
    int first_source_folder_id = -1;
    
    // Direct/ Directory and file will be creer getting first chunk
    
    log_client("Starting round-robound-robin download from " + stding(total_seeds) + " seed(s)...");
    log_client("Downloading loading in " + std::to_string(CH) + "-byte chunks...");
    
    // Initialize progress trackis tracking
    auto total_bytesded = 0LL;
    auto chunk_count = 0;
    auto estimated_total_d_total_size = get_file_size_frovailable_seeds[0], filename);
    
    // Update global progrel progress tracking
    pthreadock(&download_thread_mutex);
    if (active_download.is_active)_active) {
        active_downll_size = estimated_total_size;
        active_download.total_chtotal_chunks = (estimated_total_HUNK_SIZE - 1) / CHUNK_SIZE; // Round up
    }
    pthread_mutread_mutex_unlock(&download_thre);
    
    if (estimated_total_size <= 0) {
        estimateestimated_total_size = CHUNK_SIZ // Fallback estimate
        log_client("Using fallback file sk file size estimate: " + std::t(estimated_total_size) + " bytes");
    }
    
    // Initial Initialize progress tracking (sckground mode)
    log_client("Download Progress: Starting at 0ing at 0/" + std::to_string(estital_size) + " bytes");
    
    // Track which seeds have finiave finished and their chunk cou std::vector<bool> seed_finished(total_seeds, false);
    std::   std::vector<int> chunks_per_sl_seeds, 0);
    int active_seed_count = total_seeds;
    
      
    // Round-robin downloa download one chunk at a time
    while (total_bytes_downloadedwnloaded < estimated_total_size e_seed_count > 0) {
        auto current_seed_port = available_ailable_seeds[current_seed_index    
        // Skip finished seeds
        if (seed_finished[inished[current_seed_index]) {
    current_seed_index = (current_seed_index + 1) % total_seeds;l_seeds;
            continue; }
        
        // Connect to current seed
        auto s  auto sock = socket(AF_INET, SOM, 0);
        if (sock < 0) {
            log_client("Failed "Failed to create socket for seet " + std::to_string(current_seed_port));
            current_surrent_seed_index = (current_see+ 1) % total_seeds;
            continue;
        }
               
        struct sockaddr;
        addr.sin_family = AF_INET;
        addr.sin_port = hport = htons(current_seed_port);  inet_pton(AF_INET, "127.0.0.1", &addr.sin_addr);
        
      
        if (connect(sock, sockaddr*)&addr, sizeof(addr)) != 0) {
            log_client("client("Failed to connect to seet " + std::to_string(current_seed_port));
            close(soclose(sock);
            currentdex = (current_seed_index + 1) % total_seeds;
            conti   continue;
        }
          // Send download request with current offset - use a delimitedelimiter that won't conflict wiame
        char request[512];
        snprintf(request, sizeot, sizeof(request), "DOWNLOAD %sfilename, total_bytes_downloaded);
        send(sock, request, equest, strlen(request), 0);
          // Receive chunk data - read exactly CHUNK_SIZE bytes
 bytes
        char chunk_bufferIZE];
        auto bytes_received = 0;
        auto total_chuntal_chunk_bytes = 0;
        
// Read exactly CHUNK_SIZE bytes or until connection closes
   ses
        while (total_chunk_CHUNK_SIZE) {
            auto bytes = recv(sock, chunk_buffer _buffer + total_chunk_bytes, CHU- total_chunk_bytes, 0);
            if (bytes <= 0) {
       
                break; // Conneosed or error
            }
            total_chunk_bytes += btes += bytes;
        }
          bytes_received = total_chunk_bytes;
        
        if (b   if (bytes_received > 0) {
    // Check for error message
                    if (strncmp(chrncmp(chunk_buffer, "ERROR:", 6)
            // Don't spam error messages - this is normal whenmal when file is complete
     f (total_bytes_downloaded < estimated_total_size) {
                        log_client("Seed er port " + std::to_string(current_seed_port) + ": " + std::string::string(chunk_buffer, bytes_rec
            }
            close(sock);
            current_surrent_seed_index = (current_see+ 1) % total_seeds;
            
            // Track consecutconsecutive errors
            nt consecutive_errors = 0;
            consecutive_errors++;
 rs++;
            if (consecutis >= total_seeds * 2) {
                log_client("Too many co many consecutive errors. Downloe complete.");
                break;
            }
                    continue;
        }     
            // If this is the first chunk, determine foldine folder structure and create           if (chunk_count == 0) {
                // Map port tp port to folder ID
            (auto i = 0; i < MAX_PORTS; i++) {
                    if (POR if (PORTS[i] == current_seed_po                       first_source_folder_id = i + 1;
                                break;
            }
                }
                
                        if (first_source_fol= -1) {
                    log_client("Error: Could not determt determine folder ID for port "to_string(current_seed_port));
                    close(sock);e(sock);
                    re               }
                
                // Create doreate download directory based osuccessful seed
                snprintf(download_dir, sizeof(dsizeof(download_dir), "files/seed", 
                         my_folder_id, my_folder_id, firstd, first_source_folder_id);
        
                log_client("Creating directory: " + std:: + std::string(download_dir));
        if (create_directory(download_dir) != 0) {
                            log_client("Warnld not create directory " + std::string(download_dir));
       
                }
                          // Full path for the downloaded file
                        auto path_result = sdownload_path, sizeof(download_path), "%s/%s", download_dir, fildir, filename);
                          // Check if the path was truncated
                i       if (path_result >= sizeofd_path)) {
                    log_client("Error: File path toopath too long, cannot download."                close(sock);
                    return;
     ;
                }
                          // Create output file
                output_fiutput_file = fopen(download_path
                if (!output_file) {
                    log_c   log_client("Failed to create ile: " + std::string(download_path));
                    close   close(sock);
               urn;
                }
                
                log_c   log_client("First chunk from port " + std::to_string(current_seed_port) + " (folder ID " + stD " + std::to_string(first_sourc_id) + ")");
            }
            
            // Write / Write chunk to file
         e(chunk_buffer, 1, bytes_received, output_file);
            to      total_bytes_downloaded += ceived;
            chunk_count++;
            
            /       // Update global progressg
            pthread_mutex_lock(&download_thread_mutex);
    );
            if (active_downlctive) {
                active_download.downloaded_bytes = totes = total_bytes_downloaded;
        active_download.completed_chunks = chunk_count;
                    }
            pthreaunlock(&download_thread_mutex);
            
            // Re   // Reset consecutive failurese got data
            static int consecutive_failures = 0;
  = 0;
            consecutive_fa 0;
            
            // Check if we've reached end of  end of file (less than full chuved)
            if (bytes_received < CHUNK_SIZE) {
                        chunks_per_seed[cued_index]++; // Count the final partial chunk too
                        log_client("Port " + string(current_seed_port) + " finished sending data (sent " + stt " + std::to_string(bytes_recei bytes in final chunk) [Total chunks from this seed: " + std::to std::to_string(chunks_per_seed[seed_index]) + "]");
                seed_finished[current_seedent_seed_index] = true;
        active_seed_count--;
                
                if (act if (active_seed_count == 0 || tes_downloaded >= estimated_total_size) {
                    lo      log_client("End of file deFinal size: " + std::to_string(total_bytes_downloaded) + " bytes " bytes");
                   
                }
            } else {
                // Ful  // Full chunk received, incremter and show progress
                chunks_per_seed[current_surrent_seed_index]++;
         og_client("Port " + std::to_string(current_seed_port) + " sent 3" sent 32-byte chunk (" + std::t(chunk_count) + ") [Total from this seed: " + std::to_string(churing(chunks_per_seed[current_see) + "]");
            }
            
            // Also brealso break if we've downloaded moexpected
            if (total_bytes_downloaded >= estimated_tomated_total_size) {
           _client("Download completed. Final size: " + std::to_string(totaing(total_bytes_downloaded) + " 
                break;
            }
            
                    // Safety check: if wnloaded way more than expected, stop
            if (chunk_coununk_count > 10000) { // Prevent  loops
                log_client("Safety limit reached. Stoppi. Stopping download at " + std::g(total_bytes_downloaded) + " bytes");
                break;
break;
            }
              } else {
            log_client("Port " + std::to_string(cstring(current_seed_port) + " hae data to send");
            seed_finished[current_seed_index]d_index] = true;
            acd_count--;
            
            close(sock);
                    current_seed_index = (cued_index + 1) % total_seeds;
            
            // If al// If all seeds are finished, we
            if (active_seed_count == 0) {
                log     log_client("All seeds have  sending data. Download complete.");
                break;
  eak;
            }
           e;
        }
        
        close(sock);
        
       
        // Move to next seed inobin fashion
        current_seed_index = (current_seed_index +_index + 1) % total_seeds;
          // Add delay between chunks for better progress monitoringnitoring
        // This simulaistic network conditions and allows for status updates
                usleep(CHUNK_DELAY_MICRO;
    }
    
    if (output_file) {
        fclose(output_fiutput_file);
    }
    
    /download completion (silent background mode)
    if (total_bytetal_bytes_downloaded > 0) {
   _client("Download Progress: Completed at " + std::to_string(totaing(total_bytes_downloaded) + "/:to_string(total_bytes_downloaded) + " bytes (100.0%)");
      
        log_client("Round-robiad completed!");
        log_client("Total bytes downloaded: " aded: " + std::to_string(total_bnloaded));
        log_client("Total chunks downloaded: " + std " + std::to_string(chunk_count)    log_client("File saved to: " + std::string(download_path));path));
        
        // Shled chunk distribution
        log_client("Chunk Distribution bbution by Seed:");
        int unks_check = 0;
        for (size_t i = 0; i < total_seeds; i++eds; i++) {
            if (chuseed[i] > 0) {
                auto port = available_seeds[i];eds[i];
                auto pe = (chunks_per_seed[i] * 100.0) / chunk_count;
                        std::stringstream ss;
        ss << "  Port " << port << ": " << chunks_per_seed[i] << d[i] << " chunks (" 
           << std::fixed << std::setprecision(1) << percentage << "%)";
 "%)";
                log_clien());
                total_chunks_check += chunks_per_seed[i];eed[i];
            }
           log_client(" Verification: " + std::to_string(total_chunks_chhunks_check) + "/" + std::to_strk_count) + " chunks accounted for");
        
        // Close// Close client logging after su download
        close_client_logging();
    } else {
      
        log_client("Download fno data received.");
        std::cout << "\nDownload failed - ailed - no data received." << st
        remove(download_path);
        
        // Close clilose client logging after failedd
        close_client_logging();
    }
}

// Progress bar ess bar function to show downloass
void show_progress_bar(long long current, long long total, itotal, int bar_width) {
    if = 0) return;
    
    // Ensure progress doesn't exceed 100%
d 100%
    float progress = (flent / total;
    if (progress > 1.0f) progress = 1.0f;
    
 
    
    int pos = (int)(bar_wrogress);
    
    std::cout << "\r[";
    for (int i = 0; i  = 0; i < bar_width; ++i) {
   (i < pos) std::cout << "=";
        else if (i == pos) std::coustd::cout << ">";
        else t << " ";
    }
    std::cout << "] ";
    
    // Show perchow percentage and bytes
    st<< std::fixed << std::setprecision(1) << (progress * 100.0) << ".0) << "% ";
    std::cout << "rrent << "/" << total << " bytes)";
    
    std::cout.flush().flush();
}

// Function to cfile already exists locally with correct size
bool check_file_ak_file_already_exists(const charme, long long expected_size, char* existing_path, size_t path_si path_size) {
    // Get our fo
    auto my_folder_id = -1;
    for (auto i = 0; i < MAX_PORTSAX_PORTS; i++) {
        if (PO= my_bound_port) {
            my_folder_id = i + 1;
                    break;
        }
   
    if (my_folder_id == -1) {
        return false;
    }

    }
    
    // Check multiible locations where the file might exist
    const char* possir* possible_paths[] = {
       seed%d/%d/%s",           // Direct in our folder
        "files  "files/seed%d/%d/1/%s",       nloaded from seed 1
        "files/seed%d/%d/2/%s",         //      // Downloaded from seed 2
"files/seed%d/%d/3/%s",         // Downloaded from seed 3
     3
        "files/seed%d/%d/4/%s   // Downloaded from seed 4
        "files/seed%d/%d/5/%s"    /%s"          // Downloaded from
    };
    
    for (size_t i = 0; i < sizeof(possible_paths)e_paths) / sizeof(possible_paths+) {
        char check_path[1024];
        snprintf(check_patheck_path, sizeof(check_path), ppaths[i], my_folder_id, my_folder_id, filename);
        
      
        FILE* file = fopen(ch, "rb");
        if (file) {
            // Get file size
  size
            fseek(file, 0,D);
            long long file_size = ftell(file);
                    fclose(file);
                  // Check if size matches expected size
            if      if (file_size == expected_
                // Copy the path where we found the file
     e
                if (strlen(ch) < path_size) {
                    strcpy(existing_path, checth, check_path);
              turn true;
                }
            }
        }
    }

    }
    
    return false; Function to get file size from a specific seed using FILESIZE cLESIZE command
long long get_fifrom_seed(int port, const char* filename) {
    auto sock = socck = socket(AF_INET, SOCK_STREAM   if (sock < 0) {
        return -1;
    }
    
    struct  struct sockaddr_in addr;
    afamily = AF_INET;
    addr.sin_port = htons(port);
    inet_pt inet_pton(AF_INET, "127.0.0.1",in_addr);
    
    if (connect(sock, (struct sockaddr*)&addr, )&addr, sizeof(addr)) != 0) {
 lose(sock);
        return -1;
    }
    
    // Send FILESId FILESIZE request to get exact e
    char request[512];
    snprintf(request, sizeof(request)request), "FILESIZE %s", filenam send(sock, request, strlen(request), 0);
    
    // Read theRead the file size response
   ffer[64];
    auto bytes_received = recv(sock, buffer, sizeof(bsizeof(buffer) - 1, 0);
    
 (sock);
    
    if (bytes_received > 0) {
        buffer[bytffer[bytes_received] = '\0';
   (strncmp(buffer, "SIZE:", 5) == 0) {
            long long fillong file_size = atoll(buffer +          log_client("Exact file size from seed: " + std::to_stri:to_string(file_size) + " bytes"        return file_size;
        }
    }
    
    // Fallba/ Fallback: use a reasonable def unknown files
    log_client("Could not determine file size, u size, using default estimate");turn 1024 * 1024; // 1MB default
}

// Port2Port File Discove Discovery - connect to other rustances
void listAvailableFiles() {
    log_client("Searching arching for files...");
    std< "\nSearching for files... " << std::endl;
    
    // Reset / Reset file counter
    pthrealock(&file_list_mutex);
    unique_file_count = 0;
    pthread pthread_mutex_unlock(&file_list
    
    auto seeds_found = 0;
    
    // Try to connect tonnect to all other ports
    f i = 0; i < MAX_PORTS; i++) {
        auto port = PORTS[i];
  [i];
        if (port != my_bou {
            log_client("Trying to connect to port " + std::t+ std::to_string(port));
      d::cout << "Trying to connect to port " << port << " ";
       
            
            //thireate a socket for the port
            auto sock = socket(AF_Iket(AF_INET, SOCK_STREAM, 0);
    if (sock < 0) {
                log_client("socket failed foailed for port " + std::to_strin;
                std::cout << "socket failed" << std::endl;
 endl;
                continue;      }
            
            struct sockaddr_in addr;
   dr;
            addr.sin_familyET;
            addr.sin_port = htons(port);
            inet_   inet_pton(AF_INET, "127.0.0.1.sin_addr);
            
            if (connect(sock, (struct (struct sockaddr*)&addr, sizeof== 0) {
                send(sock, "LIST", strlen("LIST"), 0);"), 0);
                
        char buffer[1024];
                auto n = recv(sock, buffek, buffer, sizeof(buffer) - 1, 0            if (n > 0) {
                    buffer[n] = '\0';= '\0';
                    log"connected to port " + std::to_string(port) + ", found files");iles");
                    std< "connected, found files" << std::endl;
                    se      seeds_found++;
            
                    // Parse response and add files
       
                    auto line =buffer, "\n");
                    while (line != NULL) {
     {
                        auto_end = strchr(line, ']');
                        if (bracket_eracket_end && bracket_end[1] ==                             add_unique_file(bracket_end + 2, por+ 2, port);
                                           line = strtok(NULL, "\n");
                            }
             e {
                    log_client("no response from port " + srt " + std::to_string(port));
            std::cout << "no response" << std::endl;
                        }
            } el              log_client("port " + std::to_string(port) + " not + " not running");
            :cout << "not running" << std::endl;
            }
                    
            close(soc     }
    }
    
    log_client("Search completed.");
    s;
    std::cout << "done." << s;
    
    // Display results
    pthread_mutex_lock(&file_li&file_list_mutex);
    if (uniqcount == 0) {
        log_client("No files found from port instort instances. (No other instancr to be running)");
        std::cout << "No files found from pd from port instances." << std::       std::cout << "(No other instances appear to be running)" nning)" << std::endl;
    } els     log_client("Files available. Found files from " + std::to_std::to_string(seeds_found) + " rort(s)");
        std::cout << "Files available." << std::endl;d::endl;
        for (auto i = nique_file_count; i++) {
            log_client("[" + std::to_std::to_string(i + 1) + "] " + stg(unique_files[i].filename) + " (from port " + std::to_string(untring(unique_files[i].source_por);
            std::cout << "[" << i + 1 << "] " << 
                        unique_files[i].f<< " (from port " << unique_files[i].source_port << ")" << std::<< std::endl;
        }
      out << "\n(Found files from " << seeds_found << " running port(sg port(s))" << std::endl;
    }hread_mutex_unlock(&file_list_mutex);
}

void show_download_swnload_status() {
    std::coutownload status:" << std::endl;
    
    pthread_mutex_lock(&dolock(&download_thread_mutex);
 ctive_download.is_active) {
        // Calculate percentage
  tage
        double percentage         if (active_download.total_size > 0) {
            perce   percentage = (double)active_ddownloaded_bytes / active_download.total_size * 100.0;
                }
        
        // izes
        std::string downloaded_str = format_file_size(actiize(active_download.downloaded_b        std::string total_str = format_file_size(active_downloaddownload.total_size);
         // Display progress
        std::cout << "[1] " << active_downive_download.filename << "  " 
          << downloaded_str << "/" << total_str 
                          << " (" << std::fixe::setprecision(2) << percentage << "%)" << std::endl;
    } els   } else {
        std::cout <tive downloads." << std::endl;
    }
    pthread_mutex_unlock(_unlock(&download_thread_mutex);oid show_menu() {
    auto choice = 0;
    do {
        std::   std::cout << "\nSeed App me\n    std::cout << "[1] List available files.\n";
        std::co std::cout << "[2] Download file       std::cout << "[3] Download status.\n";
        std::couttd::cout << "[4] Exit.\n";
    :cout << "\n ? ";

        std::cin >> choice;
        std::c  std::cout << "\n";

        choice) {
            case 1:
                listAvailableFillableFiles();
                b           case 2:
                download_file();
                        break;
          :
                show_download_status();
                brea    break;
            case 4:         std::cout << "Exiting..." << std::endl;
                        break;
            de                std::cout << "Invalid choice. Please try again." again." << std::endl;
         while (choice != 4);
}

int main() {
    bound_port_count =_count = 0;
    unique_file_cou
    my_bound_port = -1;
    
    // Initialize download threaad thread data
    active_downlctive = false;
    active_download.available_seeds = nullptr;
llptr;
    active_download.tota 0;
    active_download.downloaded_bytes = 0;
    active_downlve_download.total_chunks = 0;
 e_download.completed_chunks = 0;
    
    // Start single portgle port server
    port_server 
    if (my_bound_port == -1) {
        std::cout << "Could n"Could not bind to any port. Exi< std::endl;
        return 1;
    }
    
    show_menu();
enu();
    
    // Clean up
 ort_threads[0].is_bound && port_threads[0].socket_FileHandle >= ndle >= 0) {
        close(port[0].socket_FileHandle);
    }
    
    // Close any active loctive logging
    close_client_);
    close_server_logging();
    
    pthread_mutex_destroy_destroy(&file_list_mutex);
   _mutex_destroy(&client_log_mutex);
    pthread_mutex_destroy(&sstroy(&server_log_mutex);
    putex_destroy(&download_thread_mutex);
    
    return 0;
}
 0;
}
